INSERT INTO exam (category, question_text, answer_text) VALUES ('Theory','파일 구조: 레코드 접근 방법은 순차 접근, (   ) 접근, 해싱 접근 등이 있다. 키 값과 포인터 쌍으로 저장해 빠르게 탐색하는 접근 방법은 무엇인가?','인덱스(색인) 접근');
INSERT INTO exam (category, question_text, answer_text) VALUES ('Theory','관계 데이터베이스에서 열(Column)을 의미하며 속성(Attribute) 또는 특성을 나타내는 구성 요소는 무엇인가? (보기: Cardinality, Domain, Attribute, Degree, Schema, Tuple)','Attribute');
INSERT INTO exam (category, question_text, answer_text) VALUES ('Theory','원격 접속 보안 프로토콜로 암호화 통신을 제공하며 22번 포트를 사용하는 Telnet 대체 프로토콜은 무엇인가?','SSH');
INSERT INTO exam (category, question_text, answer_text) VALUES ('Theory','스케줄링: (1) 짧은 CPU burst 우선, Shortest Next CPU Burst. (2) (1)을 선점형으로 구현. 각 명칭을 쓰시오.','(1) SJF (Shortest Job First) (2) SRT (Shortest Remaining Time)');
INSERT INTO exam (category, question_text, answer_text) VALUES ('Java','Java 코드 실행 결과를 쓰시오.\npublic class Main {\n  public static void change(String[] data, String s){\n    data[0] = s;\n    s = "Z";\n  }\n  public static void main(String[] args){\n    String data[] = {"A"};\n    String s = "B";\n    change(data, s);\n    System.out.print(data[0] + s);\n  }\n}','BB');
INSERT INTO exam (category, question_text, answer_text) VALUES ('Theory','IP 223.13.234.132, 서브넷 마스크 255.255.255.192. 네트워크 주소와 사용 가능한 호스트 수를 쓰시오.','223.13.234.128, 62');
INSERT INTO exam (category, question_text, answer_text) VALUES ('Theory','대리 객체를 사용해 접근을 제어하거나 추가 기능을 제공하는 디자인 패턴은?','Proxy');
INSERT INTO exam (category, question_text, answer_text) VALUES ('Theory','웹 데이터 교환 방식: (1) 페이지 전체를 다시 로드하지 않고 JavaScript와 XML/JSON으로 일부만 비동기 갱신하는 기술. (2) HTML만으로 어려운 동적 기능을 가능하게 해 상호작용을 높이는 기법.','(1) AJAX (2) DHTML');
INSERT INTO exam (category, question_text, answer_text) VALUES ('Java','Java 코드 실행 결과를 쓰시오.\npublic class Main {\n  static interface F { int apply(int x) throws Exception; }\n  public static int run(F f){\n    try { return f.apply(3); } catch (Exception e){ return 7; }\n  }\n  public static void main(String[] args){\n    F f = (x) -> { if (x > 2) throw new Exception(); return x * 2; };\n    System.out.print(run(f) + run((int n) -> n + 9));\n  }\n}','19');
INSERT INTO exam (category, question_text, answer_text) VALUES ('Java','Java 코드 실행 결과를 쓰시오.\nclass Parent {\n  public int x(int i){ return i + 2; }\n  public static String id(){ return "P"; }\n}\nclass Child extends Parent {\n  public int x(int i){ return i + 3; }\n  public String x(String s){ return s + "R"; }\n  public static String id(){ return "C"; }\n}\npublic class Main {\n  public static void main(String[] args){\n    Parent ref = new Child();\n    System.out.println(ref.x(2) + ref.id());\n  }\n}','5P');
INSERT INTO exam (category, question_text, answer_text) VALUES ('Theory','제어 흐름 그래프의 분기 커버리지를 만족하는 테스트 순서를 쓰시오. (그림 기준)','1234561, 124567 또는 1234567, 124561');
INSERT INTO exam (category, question_text, answer_text) VALUES ('C','C 코드 실행 결과를 쓰시오.\n#define SIZE 3\ntypedef struct { int a[SIZE]; int front; int rear; } Queue;\nvoid enq(Queue* q, int val){ q->a[q->rear] = val; q->rear = (q->rear + 1) % SIZE; }\nint deq(Queue* q){ int val = q->a[q->front]; q->front = (q->front + 1) % SIZE; return val; }\nint main(){ Queue q = {{0},0,0}; enq(&q,1); enq(&q,2); deq(&q); enq(&q,3); int first = deq(&q); int second = deq(&q); printf("%d 그리고 %d", first, second); }','2 그리고 3');
INSERT INTO exam (category, question_text, answer_text) VALUES ('Theory','라운드로빈(RR) 스케줄링: 타임 퀀텀 4ms, 도착/실행시간 P1(0,8) P2(1,4) P3(2,9) P4(3,5). 평균 대기시간은?','11.75ms');
INSERT INTO exam (category, question_text, answer_text) VALUES ('C','C 코드 실행 결과를 쓰시오.\nstruct dat { int x; int y; };\nint main(){ struct dat a[] = {{1,2},{3,4},{5,6}}; struct dat* ptr = a; struct dat** pptr = &ptr; (*pptr)[1] = (*pptr)[2]; printf("%d 그리고 %d", a[1].x, a[1].y); }','5 그리고 6');
INSERT INTO exam (category, question_text, answer_text) VALUES ('Java','Java 코드 실행 결과를 쓰시오.\nclass BO { public int v; public BO(int v){ this.v = v; } }\npublic class Main {\n  public static void main(String[] args){\n    BO a = new BO(1); BO b = new BO(2); BO c = new BO(3);\n    BO[] arr = {a,b,c}; BO t = arr[0]; arr[0] = arr[2]; arr[2] = t;\n    arr[1].v = arr[0].v; System.out.println(a.v + "a" + b.v + "b" + c.v);\n  }\n}','1a3b3');
INSERT INTO exam (category, question_text, answer_text) VALUES ('C','C 코드 실행 결과를 쓰시오.\nstruct node { int p; struct node* n; };\nint main(){ struct node a={1,NULL}; struct node b={2,NULL}; struct node c={3,NULL}; a.n=&b; b.n=&c; c.n=NULL; c.n=&a; a.n=&b; b.n=NULL; struct node* head=&c; printf("%d %d %d", head->p, head->n->p, head->n->n->p); }','3 1 2');
INSERT INTO exam (category, question_text, answer_text) VALUES ('Python','Python 코드 실행 결과를 쓰시오.\nlst = [1,2,3]\ndst = {i: i*2 for i in lst}\ns = set(dst.values())\nlst[0] = 99\ndst[2] = 7\ns.add(99)\nprint(len(s & set(dst.values())))','2');
INSERT INTO exam (category, question_text, answer_text) VALUES ('C','C 코드 실행 결과를 쓰시오.\nstruct node { char c; struct node* p; };\nstruct node* func(char* s){ struct node* h=NULL, *n; while(*s){ n=malloc(sizeof(struct node)); n->c=*s++; n->p=h; h=n; } return h; }\nint main(){ struct node* n = func("BEST"); while(n){ putchar(n->c); struct node* t=n; n=n->p; free(t); } }','TSEB');
INSERT INTO exam (category, question_text, answer_text) VALUES ('Theory','TCP 3-way handshake에서 마지막 ACK를 보내지 않아 서버가 연결 대기 상태가 지속되고 서비스 거부가 발생하는 공격은?','SYN Flooding');
INSERT INTO exam (category, question_text, answer_text) VALUES ('Theory','릴레이션 employee 테이블 (Index, AGE, TTL) 값이 (1,55,부장),(2,35,대리),(3,42,과장),(4,45,차장)일 때, π TTL(employee) 결과를 쓰시오.','부장, 대리, 과장, 차장');
INSERT INTO exam (category, question_text, answer_text) VALUES ('Theory','다음은 네트워크 보안에 관련된 문제이다. 괄호안에 알맞는 용어를 작성하시오.\n\n( )은/는 \'세션을 가로채다.\' 라는 의미로 다른 사람의 세션 상태를 훔치거나 도용하여 액세스하는 해킹 기법이다.\n\nTCP ( )은/는 TCP의 3-way 핸드셰이크가 완료된 후에 공격자가 시퀀스 번호 등을 조작하여 정상적인 세션을 가로채고 인증 없이 통신을 탈취하는 공격 공격이다.','세션 하이재킹');
INSERT INTO exam (category, question_text, answer_text) VALUES ('Theory','다음은 제약조건과 관련된 문제이다. 괄호안에 알맞는 용어를 보기에 골라 작성하시오.\n\n(ㄱ) 무결성 제약조건: 제약 대상은 속성, NULL 값은 -, 릴레이션 내 제약조건의 개수는 속성의 개수와 동일, 기타는 튜플 삽입/수정 시 제약사항 우선 확인.\n(ㄴ) 무결성 제약조건: 제약 대상은 튜플, NULL 값은 기본키, 릴레이션 내 제약조건의 개수는 1개, 기타는 튜플 삽입/수정 시 제약사항 우선 확인.\n(ㄷ) 무결성 제약조건: 제약 대상은 속성과 튜플, NULL 값은 외래키, 릴레이션 내 제약조건의 개수는 0~여러 개, 기타는 튜플 삽입/수정 시 제약사항 우선 확인 및 부모 릴레이션의 튜플 수정/삭제 시 제약사항 우선 확인.\n\n[보기] 개체, 참조, 도메인','ㄱ. 도메인, ㄴ. 개체, ㄷ. 참조');
INSERT INTO exam (category, question_text, answer_text) VALUES ('Theory','아래의 내용에서 설명 글의 괄호안의 용어를 영문 약자로 작성하시오.\n\n( )은/는 3글자의 영어 약자로 이루어진 오류 기법으로 데이터를 전송하거나 저장할 때 데이터의 오류를 감지하는 데 사용되는 오류 검출 코드이다.\n\n( )은/는 데이터에 체크섬을 추가하여 데이터를 전송하거나 저장한 후, 수신 또는 읽을 때 이 체크섬을 다시 계산하여 데이터가 변경되었는지 확인하는 기법이다.\n\n( )은/는 데이터 전송의 안정성을 높이는 데 중요한 역할을 한다.\n\n데이터는 이진수(0과 1)로 표현되며 정해진 다항식(x^3 + x + 1)을 기반으로 데이터를 2진수 나눗셈하고 나머지를 ( ) 값으로 삼는다.','CRC');
INSERT INTO exam (category, question_text, answer_text) VALUES ('Theory','다음은 악성코드 관련된 문제이다. 아래 내용을 확인하여 보기에 골라 작성하시오.\n\n사용자가 원치 않는 소프트웨어를 구매하도록 조작하기 위해 사회 공학을 사용하여 충격, 불안 또는 위협에 대한 인식을 유발하는 악성 소프트웨어의 한 형태이다.\n\n\'겁을 주다\'라는 영어 단어에서 유래한 것으로 공포를 이용하여 피해자를 속여 대가를 지불하거나 특정 행동을 유도하는 랜섬웨어이다.\n\n가짜 바이러스 경고나 시스템 문제를 표시하여 사용자가 돈을 지불하거나 특정 소프트웨어를 설치하도록 속이는 방식으로 작동한다.\n\n보기\nㄱ. 컴포넌트 웨어 ㄴ. 유즈웨어 ㄷ. 셔블웨어 ㄹ. 스캐어 웨어 ㅁ. 안티 스파이 웨어 ㅂ. 네트웨어 ㅅ. 그룹웨어 ㅇ. 애드웨어','스캐어 웨어');
INSERT INTO exam (category, question_text, answer_text) VALUES ('Java','Java 코드 실행 결과를 쓰시오.\npublic class Main {\n  public static void main(String[] args) {\n    int a = 5, b = 0;\n    try {\n      System.out.print(a / b);\n    } catch (ArithmeticException e) {\n      System.out.print("출력1");\n    } catch (ArrayIndexOutOfBoundsException e) {\n      System.out.print("출력2");\n    } catch (NumberFormatException e) {\n      System.out.print("출력3");\n    } catch (Exception e) {\n      System.out.print("출력4");\n    } finally {\n      System.out.print("출력5");\n    }\n  }\n}','출력1출력5');
INSERT INTO exam (category, question_text, answer_text) VALUES ('Theory','아래 내용은 ARP/RARP에 대한 설명이다. 각 설명에 해당하는 것을 작성하시오.\n\n(1)은/는 네트워크상에서 IP 주소를 MAC 주소로 변환하는 프로토콜이고,\n(2)은/는 MAC 주소를 IP 주소로 변환하는 프로토콜이다.','(1) ARP (2) RARP');
INSERT INTO exam (category, question_text, answer_text) VALUES ('Theory','다음은 SQL 문제이다. 아래 두 테이블을 참고하여 보기에 쿼리 실행 결과를 작성하시오.\n\n[emp 테이블]\nid | name\n1001 | 김철수\n1002 | 홍길동\n1004 | 강감찬\n1008 | 이순신\n\n[sal 테이블]\nid | incentives\n1002 | 300\n1004 | 300\n1008 | 1000\n1009 | 500\n\n[보기]\nSELECT name, incentive FROM emp, sal WHERE emp.id = sal.id and incentives >= 500','이순신 | 1000');
INSERT INTO exam (category, question_text, answer_text) VALUES ('Theory','아래는 데이터베이스에 관련된 설명이다. 알맞는 용어를 보기에서 골라 괄호를 작성하시오.\n1. 릴레이션에서 속성의 개수를 의미: (1)\n2. 릴레이션에서 튜플의 개수를 의미: (2)\n3. 한 릴레이션의 속성이 다른 릴레이션의 기본 키를 참조할 때, 참조하는 속성을 의미: (3)\n4. 특정 속성에 대해 입력될 수 있는 값의 유형이나 범위를 의미하고 무결성을 보장하는 기준: (4)\n\n[보기]\nㄱ. domain  ㄴ. primary  ㄷ. degree  ㄹ. candidate  ㅁ. cardinality  ㅂ. attribute  ㅅ. foreign','ㄷ, ㅁ, ㅅ, ㄱ');
INSERT INTO exam (category, question_text, answer_text) VALUES ('Theory','IP 주소가 192.168.35.10, 서브넷 255.255.252.0인 PC에서 브로드캐스팅으로 다른 IP로 정보를 전달한다고 할 때 수신할 수 있는 알맞는 IP를 보기에서 골라 모두 작성하시오.\n\n[보기]\nㄱ. 192.168.34.1\nㄴ. 192.168.32.19\nㄷ. 192.168.35.200\nㄹ. 192.168.33.138\nㅁ. 192.168.35.50','ㄱ, ㄴ, ㄷ, ㄹ, ㅁ');
INSERT INTO exam (category, question_text, answer_text) VALUES ('C','C 코드 실행 결과를 쓰시오.\n#include <stdio.h>\nchar Data[5] = {\'B\', \'A\', \'D\', \'E\'};\nchar c;\n\nint main(){\n  int i, temp, temp2;\n  c = \'C\';\n  printf("%d\\n", Data[3]-Data[1]);\n  for(i=0;i<5;++i){\n    if(Data[i]>c)\n      break;\n  }\n  temp = Data[i];\n  Data[i] = c;\n  i++;\n  for(;i<5;++i){\n    temp2 = Data[i];\n    Data[i] = temp;\n    temp = temp2;\n  }\n  for(i=0;i<5;++i){\n    printf("%c", Data[i]);\n  }\n}','4\nBACDE');
INSERT INTO exam (category, question_text, answer_text) VALUES ('C','C 코드 실행 결과를 쓰시오.\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid set(int** arr, int* data, int rows, int cols) {\n  for (int i = 0; i < rows * cols; ++i) {\n    arr[((i + 1) / rows) % rows][(i + 1) % cols] = data[i];\n  }\n}\n\nint main() {\n  int rows = 3, cols = 3, sum = 0;\n  int data[] = {5, 2, 7, 4, 1, 8, 3, 6, 9};\n  int** arr;\n  arr = (int**) malloc(sizeof(int*) * rows);\n  for (int i = 0; i < cols; i++) {\n    arr[i] = (int*) malloc(sizeof(int) * cols);\n  }\n\n  set(arr, data, rows, cols);\n\n  for (int i = 0; i < rows * cols; i++) {\n    sum += arr[i / rows][i % cols] * (i % 2 == 0 ? 1 : -1);\n  }\n\n  for (int i = 0; i < rows; i++) {\n    free(arr[i]);\n  }\n  free(arr);\n\n  printf("%d", sum);\n}','13');
INSERT INTO exam (category, question_text, answer_text) VALUES ('Theory','다음은 결합도와 관련된 내용이다. 보기에 알맞는 답을 골라 작성하시오.\n(1) 다른 모듈 내부에 있는 변수나 기능을 다른 모듈에서 사용하는 경우의 결합도\n(2) 모듈 간의 인터페이스로 배열이나 오브젝트, 자료구조 등이 전달되는 경우의 결합도\n(3) 파라미터가 아닌 모듈 밖에 선언되어 있는 전역 변수를 참조하고 전역 변수를 갱신하는 식으로 상호작용하는 경우의 결합도\n\n[보기]\nㄱ. 자료 결합도  ㄴ. 스탬프 결합도  ㄷ. 제어 결합도  ㄹ. 공통 결합도  ㅁ. 내용 결합도  ㅂ. 외부 결합도','(1) ㅁ (2) ㄴ (3) ㄹ');
INSERT INTO exam (category, question_text, answer_text) VALUES ('Java','Java 코드 실행 결과를 쓰시오.\npublic class Main {\n  public static void main(String[] args) {\n    new Child();\n    System.out.println(Parent.total);\n  }\n}\n\nclass Parent {\n  static int total = 0;\n  int v = 1;\n  public Parent() {\n    total += (++v);\n    show();\n  }\n  public void show() {\n    total += total;\n  }\n}\n\nclass Child extends Parent {\n  int v = 10;\n  public Child() {\n    v += 2;\n    total += v++;\n    show();\n  }\n  @Override\n  public void show() {\n    total += total * 2;\n  }\n}','54');
INSERT INTO exam (category, question_text, answer_text) VALUES ('Theory','아래는 디자인 패턴에 대한 설명이다. 알맞는 답을 보기에 골라 작성하시오.\n서로 다른 인터페이스를 가진 클래스들을 연결해 사용 가능하게 한다.\n기존 클래스(Adaptee)를 원하는 인터페이스(Target)에 맞게 변환하는 어댑터(Adapter)를 만든다.\n기존 클래스를 감싸서(wrapper) 인터페이스를 변환해주는 역할을 한다.','Adapter');
INSERT INTO exam (category, question_text, answer_text) VALUES ('Theory','문장(Statement) 커버리지 테스트를 수행하려고 한다. 코드를 아래의 제어 흐름도 빈칸에 연결되도록 작성하고 문장 커버리지 순서대로 작성하시오.\n\nint Main(int b[], int m, int x) {\n  int a = 0;\n  while (a < m || b[a] < x) {\n    if (b[a] < 0)\n      b[a] = -b[a];\n    a++;\n  }\n  return 1;\n}\n\n(1) (  )  (2) (  )  (3) (  )  (4) (  )  (5) (  )  (6) (  )\n문장 커버리지 순서 1 -> 2 -> (  )','(1) int a = 0 (2) a < m || b[a] < x (3) b[a] < 0 (4) b[a] = -b[a]; (5) a++; (6) return 1; (7) 3 -> 4 -> 5 -> 2 -> 6');
INSERT INTO exam (category, question_text, answer_text) VALUES ('Java','Java 코드 실행 결과를 쓰시오.\npublic class Main {\n  public static void main(String[] args) {\n    int[] data = {3, 5, 8, 12, 17};\n    System.out.println(func(data, 0, data.length - 1));\n  }\n  static int func(int[] a, int st, int end) {\n    if (st >= end) return 0;\n    int mid = (st + end) / 2;\n    return a[mid] + Math.max(func(a, st, mid), func(a, mid + 1, end));\n  }\n}','20');
INSERT INTO exam (category, question_text, answer_text) VALUES ('Python','Python 코드 실행 결과를 쓰시오.\nclass Node:\n  def __init__(self, value):\n    self.value = value\n    self.children = []\n\ndef tree(li):\n  nodes = [Node(i) for i in li]\n  for i in range(1, len(li)):\n    nodes[(i - 1) // 2].children.append(nodes[i])\n  return nodes[0]\n\ndef calc(node, level=0):\n  if node is None:\n    return 0\n  return (node.value if level % 2 == 1 else 0) + sum(calc(n, level + 1) for n in node.children)\n\nli = [3, 5, 8, 12, 15, 18, 21]\nroot = tree(li)\nprint(calc(root))','13');
INSERT INTO exam (category, question_text, answer_text) VALUES ('C','C 코드 실행 결과를 쓰시오.\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Data {\n  int value;\n  struct Data *next;\n} Data;\n\nData* insert(Data* head, int value) {\n  Data* new_node = (Data*)malloc(sizeof(Data));\n  new_node->value = value;\n  new_node->next = head;\n  return new_node;\n}\n\nData* reconnect(Data* head, int value) {\n  if (head == NULL || head->value == value) return head;\n  Data *prev = NULL, *curr = head;\n  while (curr != NULL && curr->value != value) {\n    prev = curr;\n    curr = curr->next;\n  }\n  if (curr != NULL && prev != NULL) {\n    prev->next = curr->next;\n    curr->next = head;\n    head = curr;\n  }\n  return head;\n}\n\nint main() {\n  Data *head = NULL, *curr;\n  for (int i = 1; i <= 5; i++)\n    head = insert(head, i);\n  head = reconnect(head, 3);\n  for (curr = head; curr != NULL; curr = curr->next)\n    printf("%d", curr->value);\n  return 0;\n}','35421');
INSERT INTO exam (category, question_text, answer_text) VALUES ('Theory','다음은 UML (  ) 다이어그램이다. 아래 내용을 보고 다이어그램의 관계를 확인하여 명칭을 작성하시오.\n\n( ) 다이어그램이란 시스템을 폴더 모양의 ( ) 단위로 구분하여 구성 요소 간의 관계를 표현하는 UML 구조 다이어그램이다.\n하나의 ( ) 안에는 여러 클래스나 하위 ( ) 가 포함될 수 있으며,\n( ) 간에는 <<import>>, <<access>>, <<merge>> 등의 관계를 통해 의존성(Dependency)을 표현한다.\n\n이 다이어그램은 코드의 실제 구조(폴더 구조)와 비슷하게 표현되기 때문에 소프트웨어의 모듈화, 재사용성, 의존 관계를 시각적으로 설계할 때 자주 사용된다.','패키지');
INSERT INTO exam (category, question_text, answer_text) VALUES ('Theory','다음은 소프트웨어 테스트 기법 중 하나에 대한 설명이다.\n\n소프트웨어 테스트의 구조 기반(화이트박스) 기법 중 하나로, 결정 포인트(Decision Point) 내에 존재하는 모든 개별 조건식(Atomic Condition)을 대상으로 하는 커버리지 기준이다.\n\n하나의 결정문(예: if (A && B) 또는 if (X > 10 || Y == 0)) 안에는 여러 개의 조건식이 포함될 수 있는데 이 커버리지는 각각의 조건식이 True와 False 두 가지 경우를 모두 한 번 이상 만족하도록 테스트 케이스를 설계해야 한다.\n\n즉, 모든 개별 조건이 두 방향의 결과를 거쳐야 \'커버되었다\'고 판단하지만 그렇다고 해서 전체 결정식(Decision Expression)의 결과(True/False)가 모두 수행된다고 보장하지는 않는다.\n\n[보기]\nㄱ. 경로(Path)  ㄴ. 결정(Decision)  ㄷ. 조건/결정(Condition/Decision)  ㄹ. 변경 조건/결정(Modified Condition/Decision, MC/DC)  ㅁ. 다중 조건(Multiple Condition)  ㅂ. 문장(Statement)  ㅅ. 분기(Branch)  ㅇ. 조건(Condition)  ㅈ. 루프(Loop)','ㅇ');
INSERT INTO exam (category, question_text, answer_text) VALUES ('C','C 코드 실행 결과를 쓰시오.\n#include <stdio.h>\n\ntypedef struct student {\n  char* name;\n  int score[3];\n} Student;\n\nint dec(int enc) {\n  return enc & 0xA5;\n}\n\nint sum(Student* p) {\n  return dec(p->score[0]) + dec(p->score[1]) + dec(p->score[2]);\n}\n\nint main() {\n  Student s[2] = { "Kim", {0xA0, 0xA5, 0xDB}, "Lee", {0xA0, 0xED, 0x81} };\n  Student* p = s;\n  int result = 0;\n  for (int i = 0; i < 2; i++) {\n    result += sum(&s[i]);\n  }\n  printf("%d", result);\n  return 0;\n}','908');
INSERT INTO exam (category, question_text, answer_text) VALUES ('Java','Java 코드 실행 결과를 쓰시오.\npublic class Main {\n  public static void main(String[] args) {\n    System.out.println(calc("5"));\n  }\n  static int calc(int value) {\n    if (value <= 1) return value;\n    return calc(value - 1) + calc(value - 2);\n  }\n  static int calc(String str) {\n    int value = Integer.valueOf(str);\n    if (value <= 1) return value;\n    return calc(value - 1) + calc(value - 3);\n  }\n}','4');
INSERT INTO exam (category, question_text, answer_text) VALUES ('Theory','다음은 유닉스(Unix) 또는 리눅스(Linux) 환경에서 자주 사용하는 기본 명령어에 대한 설명이다. 각 설명에 맞는 명령어를 보기에 골라 연결하시오.\n\n1. 현재 작업 중인 디렉터리의 경로를 출력한다. ( )\n2. 디렉터리의 내용(파일 및 하위 디렉터리)을 목록으로 표시한다. ( )\n3. 다른 디렉터리로 이동한다. ( )\n4. 파일을 복사한다. ( )\n\n[보기]\nls, cd, cp, pwd','1. pwd 2. ls 3. cd 4. cp');
INSERT INTO exam (category, question_text, answer_text) VALUES ('Theory','다음은 오류검출 방식을 설명하는 내용이다. 설명의 빈칸 (①)~(⑤)에 들어갈 알맞은 용어를 <보기>에서 고르시오.\n\n(①) 코드는 전송 데이터에 여러 개의 검사 비트를 추가하여 오류를 검출하고 수정까지 가능한 방법이다. 이 코드는 재전송 없이 수신 측에서 자체 수정하는 (②) 방식에 속한다.\n이에 반해 오류 발생 시 송신 측에 재전송을 요구하는 방식은 (③)이라 하며, 여기에 포함되는 대표적 검출 기법으로 (④) 검사와 (⑤) 검사가 있다.\n\n(④) 검사는 데이터 블록 끝에 1비트 검사 비트를 추가하여 오류를 검출한다.\n(⑤) 검사는 송신측과 수신측이 동일한 특정 다항식을 사용하여 오류를 검출한다.\n\n[보기]\nㄱ. CRC  ㄴ. FEC  ㄷ. BEC  ㄹ. NAK  ㅁ. Parity  ㅂ. MD5  ㅅ. BCD  ㅇ. Hamming','① ㅇ ② ㄴ ③ ㄷ ④ ㅁ ⑤ ㄱ');
INSERT INTO exam (category, question_text, answer_text) VALUES ('C','C 코드 실행 결과를 쓰시오.\n#include <stdio.h>\n\nstruct Test {\n  int i;\n  const char *g;\n};\n\nint main() {\n  struct Test test[] = {{1, "AB"}, {2, "DC"}, {3, "EB"}};\n  struct Test *p = &test[1];\n  printf("%s", p->g + (p->i - 1));\n  return 0;\n}','C');
INSERT INTO exam (category, question_text, answer_text) VALUES ('C','C 코드 실행 결과를 쓰시오.\n#include <stdio.h>\n\nint main(void) {\n  char str[] = "REPUBLICOFKOREA";\n  int a = 0;\n  while (str[a] != '\\0')\n    ++a;\n  putchar(str[a - 2]);\n  return 0;\n}','E');
INSERT INTO exam (category, question_text, answer_text) VALUES ('C','C 코드 실행 결과를 쓰시오.\n#include <stdio.h>\n\nstruct Node {\n  struct Node* next;\n  unsigned int x;\n};\n\nint main() {\n  struct Node t1 = { 0, 5u };\n  struct Node t2 = { 0, 7u };\n  struct Node t3 = { 0, 11u };\n\n  t3.next = &t2;\n  t2.next = &t1;\n\n  struct Node* curr = &t3;\n  unsigned int sum = 0;\n  while (curr) {\n    sum = sum * 3 + curr->x;\n    curr = curr->next;\n  }\n  sum = (sum ^ 42u) + 100u;\n  printf("%u", sum);\n}','187');
INSERT INTO exam (category, question_text, answer_text) VALUES ('Java','다음은 Machine 이라는 인터페이스를 정의하고 WashingMachine 클래스에서 해당 인터페이스를 사용하고자 한다. 빈칸에 들어갈 올바른 키워드를 작성하시오.\n\ninterface Machine {\n  void run();\n}\n\nclass WashingMachine (____빈칸____) Machine {\n  private String name;\n\n  public WashingMachine() {\n    this.name = "LG Washer";\n  }\n\n  public void run() {\n    System.out.println("Washing machine running");\n  }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    WashingMachine wm = new WashingMachine();\n    wm.run();\n  }\n}\n','implements');
INSERT INTO exam (category, question_text, answer_text) VALUES ('Python','Python 코드 실행 결과를 쓰시오.\ndata = [\n  [3, 5, 2, 4, 1],\n  [4, 5, 1],\n  [4, 4, 1, 5, 4],\n  [4, 5]\n]\n\nresult = {}\n\nfor index, lis in enumerate(data):\n  list_sum = sum(lis)\n  list_len = len(lis)\n  result[index] = (list_sum, list_len)\n\nprint(result)','{0: (15, 5), 1: (10, 3), 2: (18, 5), 3: (9, 2)}');
INSERT INTO exam (category, question_text, answer_text) VALUES ('Theory','다음은 테이블에서 조건값을 실행한 화면이다. 이에 대한 알맞은 결과값을 작성하시오.\n\nT1\nCODE | NAME\n3258 | smith\n4324 | allen\n5432 | scott\n\nT2\nNO | RULE\n12 | s%\n32 | %t%\n\n실행값\nSELECT COUNT(*) CNT FROM T1 A CROSS JOIN T2 B\nWHERE A.NAME LIKE B.RULE;','4');
INSERT INTO exam (category, question_text, answer_text) VALUES ('Theory','다음 설명에 해당하는 인증 기술을 쓰시오.\n\n한 번 사용하면 즉시 폐기되어 재사용이 불가능하다.\n서버와 토큰(또는 앱)은 시간 동기화나 카운터 기반 방식으로 매번 새로운 값을 생성하고, 내부 검증은 해시 함수를 이용한 방식으로 서버에 평문을 저장하지 않고도 유효성을 확인할 수 있다.\n이 특성 때문에 은행 인증 등 고보안 영역에서 널리 사용되며 재전송 공격 방지와 사용자 편의성을 동시에 만족한다.','OTP');
INSERT INTO exam (category, question_text, answer_text) VALUES ('Java','다음은 Java의 상속과 생성자 호출에 관한 코드이다. 밑줄에 알맞은 단어를 작성하시오.\n\nclass Rectangle {\n  int width, height;\n  Rectangle(int width, int height) {\n    this.width = width;\n    this.height = height;\n  }\n}\n\nclass Square extends Rectangle {\n  Square(int a) {\n    ____(a, a);\n  }\n  int getSquareArea() {\n    return width * height;\n  }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    Square sq = new Square(10);\n    System.out.println(sq.getSquareArea());\n  }\n}\n','super');
INSERT INTO exam (category, question_text, answer_text) VALUES ('Theory','다음은 인증 및 자원 접근 방식에 대한 설명이다. 알맞은 단어를 작성하시오.\n\n사용자가 새로운 사이트에 가입하지 않고 평소에 이용하던 서비스의 계정으로 로그인할 수 있게 해주는 기술이다.\n사용자의 비밀번호는 절대 전달되지 않으며 사용자가 승인한 범위에 대해서만 접근 권한이 위임된다.\n이 방식은 직접 인증(Authentication)을 수행하지 않고 \'인가(Authorization)\' 절차를 통해 접근 권한을 제3자에게 부여한다.\n인증 완료 후, 서비스 제공자는 Access Token을 발급하며 애플리케이션은 이 토큰을 이용해 API를 호출하여 필요한 정보에 접근한다.\n대표적인 예는 소셜 로그인이며 SSO(Single Sign-On)과 달리 동일 시스템 내 인증이 아니라 서로 다른 서비스 간의 권한 위임에 초점이 맞춰져 있다.','OAuth');
INSERT INTO exam (category, question_text, answer_text) VALUES ('Theory','다음 아래의 테이블을 확인하여 R÷S의 결과를 테이블 형태로 기재하시오.\n\n[R 테이블]\nA | B\na1 | b1\na2 | b2\na1 | b3\n\n[S 테이블]\nB\nb1\nb3','A\na1');
INSERT INTO exam (category, question_text, answer_text) VALUES ('C','C 코드 실행 결과를 쓰시오.\n#include <stdio.h>\nint main() {\n  int x = 7, y = 4, z;\n  z = y % 3 ? 2 : 1;\n  z = z & z > 1;\n  z = x > 5 && z <= 3 ? z * x : z / x;\n  printf("%d", z);\n  return 0;\n}','0');
INSERT INTO exam (category, question_text, answer_text) VALUES ('Theory','관계형 데이터베이스 개념에 대한 설명이다. 빈칸에 들어갈 용어를 보기에서 골라 순서대로 쓰시오.\n\nㄱ. 테이블에서 한 행(Row)을 의미하며, 하나의 레코드를 구성하는 요소\nㄴ. 실제 데이터가 저장되어 있는 테이블의 내용 전체를 의미하며, 데이터의 상태를 나타낸다.\nㄷ. 테이블에 저장된 행(Row)의 총 개수를 의미한다.\n\n[보기]\n스키마(Structure)  속성(Attribute)  튜플(Tuple)  차수(Degree)  인스턴스(Instance)  카디널리티(Cardinality)','ㄱ. 튜플, ㄴ. 인스턴스, ㄷ. 카디널리티');
INSERT INTO exam (category, question_text, answer_text) VALUES ('Java','Java 코드 실행 결과를 쓰시오.\nenum Tri {\n  A("A"), B("AB"), C("ABC");\n  private String code;\n  Tri(String code) {\n    this.code = code;\n  }\n  public String code() {\n    return code;\n  }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    Tri t = Tri.values()[Tri.A.name().length()];\n    System.out.print(t.code());\n  }\n}\n','AB');
INSERT INTO exam (category, question_text, answer_text) VALUES ('Theory','다음은 정보보안에서 사용하는 접근통제(Access Control) 방식에 대한 설명이다. 설명에 해당하는 접근통제 모델을 <보기>에서 골라 빈칸에 작성하시오.\n\nㄱ. 중앙에서 보안 정책을 일괄적으로 설정하며, 주체(사용자)가 임의로 수정하거나 변경할 수 없다. 주로 군사 기밀, 국가 보안과 같은 높은 보안 수준이 요구되는 환경에서 사용된다. 보안 등급(Top Secret / Secret / Confidential) 등에 따라 접근 여부가 결정된다.\nㄴ. 조직 내에서 부여된 직무나 역할(Role)에 따라 접근 권한을 부여하는 방식이다. 개별 사용자에게 직접 권한을 설정하지 않고, 역할에 권한을 묶어 부여하기 때문에 관리가 용이하며 직무 변경 시 역할만 변경하면 된다.\nㄷ. 자원의 소유자(Owner)가 해당 자원에 대한 접근 권한을 자유롭게 부여하거나 회수할 수 있는 방식이다. 파일이나 폴더의 소유자가 읽기/쓰기/실행 권한을 설정하는 것이 대표적인 예로 사용자 임의 설정 가능해 보안성이 상대적으로 낮다.\n\n[보기]\nDAC  MAC  RBAC','ㄱ. MAC, ㄴ. RBAC, ㄷ. DAC');
INSERT INTO exam (category, question_text, answer_text) VALUES ('Theory','다음은 테스트케이스의 구성요소에 대한 설명이다. 괄호 ( ) 안에 들어갈 알맞은 보기를 고르시오.\n\n[표]\n식별자 ID | 테스트 항목 | ( ) | ( ) | ( )\nDS-45S-21 | 로그인 기능 | 사용자 초기 화면 | 사용자 아이디(Test11) 비밀번호(test@@) | 로그인 성공\nDS-45S-25 | 로그인 기능 | 사용자 초기 화면 | 사용자 아이디(Test11) 비밀번호("") | 로그인 실패\n\n[보기]\nㄱ. 테스트 조건  ㄴ. 테스트 환경  ㄷ. 테스트 유형  ㄹ. 테스트 데이터  ㅁ. 예상 결과  ㅂ. 수행 단계  ㅅ. 성공/실패 기준','ㄱ, ㄹ, ㅁ');
INSERT INTO exam (category, question_text, answer_text) VALUES ('Theory','다음은 SQL에 관한 문제이다. 아래 A테이블을 참고하여 쿼리의 결과를 작성하시오.\n\n[A 테이블]\ncol1 | col2\n2 | null\n3 | 6\n2 | 3\nnull | 3\n4 | 5\n\n[SQL]\nSELECT count(col2) FROM A WHERE col1 IN (2, 3) OR col2 IN (3, 5)','4');
